---
title: "oldCodes"
format: pdf
editor: visual
---

## parameter texts

```{r}
param_text3 <- function(param_list) {
  ggplot() +
    annotate("text", x = 0.5, y = 0.5, 
             label = paste("b_y =", param_list$b_y, "\n",
                           "b_a =", param_list$b_a, "\n",
                           "m =", param_list$m, "\n",
                           "r =",param_list$r,"\n",
                           "sigma_j =", param_list$sigma_j,"\n",
                           "sigma_a =",param_list$sigma_a,"\n",
                           "sigma_y =",param_list$sigma_y,"\n"
                           ), 
             size = 4, hjust = 0.5, vjust = 0.5) +
    theme_void()
}

param_text2 <- function(param_list) {
  ggplot() +
    annotate("text", x = 0.5, y = 0.5, 
             label = paste("b =", param_list$b, "\n",
                           "m =", param_list$m, "\n",
                           "r =",param_list$r,"\n",
                           "sigma_j =", param_list$sigma_j,"\n",
                           "Pa =",param_list$Pa
                           ), 
             size = 4, hjust = 0.5, vjust = 0.5) +
    theme_void()
}

```

## Split Pa

Here I split Pa used in 2 \* 2 matrix and into sigma_a and sigma_y in 3 \* 3 matrix. The function will return a list of all possible combinations of sigma_a and sigma_y, as well as the numbers of adults and young adults in the stable stage distribution.

p is a list of parameters used for 2 \* 2 matrix.

```{r}
expand_param <- function(p2) {
SSD2<-eigen(constructMatrix2(p2)$two_stage_matrix)$vectors[,1]/eigen(constructMatrix2(p2)$two_stage_matrix)$vectors[2,1]
N0_2<-Re(SSD2)/sum(Re(SSD2)) * 500
N_combined_adult <- N0_2[2]  # Combined adults= N_a + N_y
Pa <- p2$Pa
# ranges for survival rates
sigma_a_values <- seq(0.5, 0.95, by = 0.01)       # Adult survival
sigma_y_values <- seq(0.5, 0.95, by = 0.01)  # Young adult survival

# blank results data frame
results <- data.frame(sigma_a = numeric(), sigma_y = numeric(), N_a = numeric(), N_y = numeric())

# Iterate over combinations of sigma_a and sigma_y
for (sigma_a in sigma_a_values) {
  for (sigma_y in sigma_y_values) {
    # Assume x as the proportion of Adults, that means N_a = x * N_combined_adult, N_y = (1 - x) * N_combined_adult
    for (x in seq(0, 1, by = 0.01)) {
      N_a <- x * N_combined_adult
      N_y <- (1 - x) * N_combined_adult
      
      # Calculate Pa based on this split
      Pa_calculated <- (sigma_a * N_a + sigma_y * N_y) / N_combined_adult
      
      # Check if the calculated value matches the given combined_Pa
      # cobinations of Pa and sigma_y would only be saved if combined_Pa matches
      if (abs(Pa_calculated - Pa) < 0.001) {
        results <- rbind(results, data.frame(sigma_a = sigma_a, sigma_y = sigma_y, N_a = N_a, N_y = N_y))
      }
    }
  }
}
return(results)
}

```

## get all lambdas for sigma_a and sigma_ys

This function would create a data frame of lambdas generated by all possible combinations of sigma_a and sigma_y.

p is a list of parameters used for 2\* 2 matrix. survival_df is a data frame with one column of sigma_a and one column of sigma_y. Each row is one possible combination of sigma_a and sigma_y.

```{r}
run_multiple_combinations <- function(p, survival_df) {
  # Extract sigma_a and sigma_y as paired values
  sigma_a_values <- survival_df$sigma_a
  sigma_y_values <- survival_df$sigma_y
  
  # Initialize a data frame to store results
  results <- data.frame(sigma_a = numeric(0), sigma_y = numeric(0), lam3 = numeric(0))
  
  # Iterate through paired combinations
  for (i in 1:length(sigma_a_values)) {
    sigma_a <- sigma_a_values[i]
    sigma_y <- sigma_y_values[i]
    
    # Update the parameter list
    p$sigma_y <- sigma_y
    p$sigma_a <- sigma_a
    p$b_a <- p$b
    p$b_y <- p$b
    
    # Run constructMatrix3 and calculate lam3
    lam3 <- constructMatrix3(p)$lam3

    # Store the current lam3 along with sigma_a and sigma_y
    results <- rbind(results, data.frame(sigma_a = sigma_a, sigma_y = sigma_y, lam3 = lam3))
  }
  
  return(results)
}

```
